---
layout: post
title: JVM 应用缓慢问题的排查思路
author: zhangyue
---

## CPU 占用高
* 通过 top命令查看CPU情况，如果CPU比较高，则通过 top-Hp<pid>命令查看当前进程的各个线程运行情况
* 找出CPU过高的线程之后，将其线程id转换为十六进制的表现形式，然后在jstack日志中查看该线程主要在进行的工作。
* 这里又分为两种情况:
    * 如果是正常的用户线程，则通过该线程的堆栈信息查看其具体是在哪处用户代码处运行比较消耗CPU；
    * 如果该线程是 VMThread，则说明很可能是GC导致的CPU过高

## 内存或GC过高
* Dump
    * 通过 jstat-gcutil<pid><period><times>命令监控当前系统的GC状况 ， 或直接使用vvm
    * 然后通过 jmap dump:format=b,file=<filepath><pid>导出系统当前的内存数据，或直接使用vvm
    * 导出之后将内存情况放到vvm工具中进行分析即可得出内存中主要是什么对象比较消耗内存.

* 如果通过Dump没有发现明显的改进点，则尝试调整GC的策略来改善
    * 目标
        * GC执行非常迅速（minor 50ms以内, full 1s以内）
        * GC没有过于频繁执行（minor 10s一次, full 10min 一次）
    * 调整方式
        * 更换垃圾收集器类型
        * -Xms -Xmx
            * 大空间=GC频率低，GC时间长
            * 小空间=GC频率高，GC时间短
        * -NewRatio
            * 2-4之间尝试
    * 执行24小时结果分析

## 堵塞类型的缓慢
* 如果通过 top 命令看到CPU并不高，并且系统内存占用率也比较低。此时就可以考虑是否是由于堵塞导致的程序缓慢。
    * 如果是接口调用比较耗时，并且是不定时出现，则可以通过Tracing或Profiler工具找到缓慢的方法；
    * 如果是某个功能突然出现停滞的状况，这种情况也无法复现，此时可以通过多次导出 jstack日志的方式对比哪些用户线程是一直都处于等待状态，这些线程就是可能存在问题的线程；
    * 如果通过 jstack可以查看到死锁状态，则可以检查产生死锁的两个线程的具体阻塞点，从而处理相应的问题。

## 善用图形化工具
上述提供的命令行工具非常适合快速的的故障机本地进行先验分析。 但是如果想要提高分析的效率，还是尽量使用VVM一类的图形化工具，减轻头脑的负担。 通常JDK命令行工具提供的功能VVM全部都可以提供。
